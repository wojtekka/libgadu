<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
BODY { font-family: tahoma, verdana, arial, helvetica, sans-serif; }
.tab { background-color: #a0a0a0; }
.tabh { background-color: #d0d0d0; }
.tabf { background-color: white; }
.c { font-family: monospace; padding: 0.7em; background-color: #e0e0e0; border: 1px solid #a0a0a0; }
.http { font-family: monospace; padding: 0.7em; background-color: #c0f0c0; border: 1px solid #80a080; }
.example { font-family: monospace; padding: 0.7em; background-color: #c0f0f0; border: 1px solid #80a0a0; }
</style>
<title>Protokó³ Gadu-Gadu</title>
</head>

<body bgcolor="white" text="black">

<center>
<table width="600" border="0"><tr><td>

<center>
<h1>Protokó³ Gadu-Gadu</h1>
<h3>&copy; Copyright 2001 - 2003 <a href="#ch4">Autorzy</a></h3>
</center>

<hr />

<h2>0. Informacje wstêpne</h2>

<p>
Opis protoko³u u¿ywanego przez Gadu-Gadu bazuje na do¶wiadczeniach
przeprowadzonych przez autorów oraz informacjach nadsy³anych przez 
u¿ytkowników. ¯aden klient Gadu-Gadu nie zosta³ skrzywdzony podczas
badañ. Reverse-engineering opiera³ siê g³ównie na analizie pakietów
wysy³anych miêdzy klientem a serwerem.
</p>

<hr />

<h2>1. Protokó³ Gadu-Gadu</h2>

<h3>1.1. Format pakietów</h3>

<p>
Podobnie jak coraz wiêksza ilo¶æ komunikatorów, Gadu-Gadu korzysta z
protoko³u TCP/IP. Ka¿dy pakiet zawiera na pocz±tku dwa sta³e pola:
</p>

<div class="c">
<pre>struct gg_header {
	int type;	<i>/* typ pakietu */</i>
	int length;	<i>/* d³ugo¶æ reszty pakietu */</i>
};</pre>
</div>

<p>
Wszystkie zmienne liczbowe s± zgodne z kolejno¶ci± bajtów maszyn Intela,
czyli Little-Endian.
</p>

<p>
Przy opisie struktur, za³o¿ono, ¿e <tt>char</tt> ma rozmiar 1 bajtu,
<tt>short</tt> 2 bajtów, <tt>int</tt> 4 bajtów. U¿ywaj±c innych
architektur ni¿ i386 nale¿y zwróciæ szczególn± uwagê na rozmiar typów
zmiennych i kolejno¶æ znaków.
</p>

<p>
Pola, który znaczenie jest nieznane, lub nie do koñca jasne, oznaczono
przedrostkiem <tt>unknown</tt>.
</p>

<hr />

<h3>1.2. Zanim siê po³±czymy</h3>

<p>
¯eby wiedzieæ, z jakim serwerem mamy siê po³±czyæ, nale¿y poudawaæ przez
chwilê przegl±darkê WWW i po³±czyæ siê z hostem <tt>appmsg.gadu-gadu.pl</tt>.
</p>

<div class="http">
<pre>GET /appsvc/appmsg.asp?fmnumber=<b>NUMER</b> HTTP/1.0
Host: appmsg.gadu-gadu.pl
User-Agent: Mozilla/4.7 [en] (Win98; I)
Pragma: no-cache</pre>
</div>

<p>
Oryginalny klient mo¿e wys³aæ jeden z podanych identyfikatorów przegl±darki:
</p>

<ul>
<li><tt>Mozilla/4.04 [en] (Win95; I ;Nav)</tt></li>
<li><tt>Mozilla/4.7 [en] (Win98; I)</tt></li>
<li><tt>Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)</tt></li>
<li><tt>Mozilla/4.0 (compatible; MSIE 5.0; Windows NT)</tt></li>
<li><tt>Mozilla/4.0 (compatible; MSIE 5.0; Windows 98; DigExt)</tt></li>
<li><tt>Mozilla/4.0 (compatible; MSIE 5.0; Windows 98)</tt></li>
</ul>

<p>
Nowsze wersje (od 4.6.2) korzystaj± z innego skryptu:
</p>

<div class="http">
<pre>GET /appsvc/appmsg2.asp?fmnumber=<b>NUMER</b>&amp;version=<b>WERSJA</b>&amp;fmt=<b>FORMAT</b>&amp;lastmsg=<b>WIADOMO¦Æ</b>
Host: appmsg.gadu-gadu.pl
User-Agent: <b>PRZEGL¡DARKA</b>
Pragma: no-cache</pre>
</div>

<p>
Gdzie <b>NUMER</b> jest numerem klienta, <b>WERSJA</b> jest wersj± klienta,
<b>FORMAT</b> okre¶la czy wiadomo¶æ systemowa bêdzie przesy³ana czystym
tekstem (brak zmiennej "fmt") czy w HTMLu (jakakolwiek jej warto¶æ), a
<b>WIADOMO¦Æ</b> jest numerem ostatnio otrzymanej wiadomo¶ci systemowej.
Na postawione w ten sposób zapytanie, serwer powinien odpowiedzieæ
na przyk³ad tak:
</p>

<div class="http">
<pre>HTTP/1.0 200 OK

0 217.17.41.84:8074 217.17.41.84</pre>
</div>

<p>
Pierwsze pole jest numerem wiadomo¶ci systemowej, a drugie i trzecie
podaj± nam namiary na w³a¶ciwy serwer. Je¶li serwer jest niedostêpny,
zamiast adresu IP jest zwracany tekst ,,<tt>notoperating</tt>''.
Je¿eli po³±czenie z portem 8074 nie powiedzie siê z jakich¶ powodów,
mo¿na siê ³±czyæ na port 443. 
</p>

<p>
Je¶li pierwsza liczba nie jest równa zero, zaraz po nag³ówku znajduje siê
wiadomo¶æ systemowa, lub je¶li linia zaczyna siê od znaku ,,<tt>@</tt>'',
adres strony, któr± nale¿y otworzyæ w przegl±darce.
</p>

<hr />

<h3>1.3. Logowanie siê</h3>

<p>
Po po³±czeniu siê portem 8074 lub 443 serwera Gadu-Gadu, dostajemy pakiet
typu <tt>0x0001</tt>, który na potrzeby tego dokumentu nazwiemy:
</p>

<div class="c">
<pre>#define GG_WELCOME 0x0001</pre>
</div>

<p>
Reszta pakietu zawiera liczbê, na podstawie której liczony jest hash z has³a
klienta:
</p>

<div class="c">
<pre>struct gg_welcome {
	int seed;	<i>/* klucz szyfrowania has³a */</i>
};</pre>
</div>

<p>
Kiedy mamy ju¿ t± warto¶æ mo¿emy odes³aæ pakiet logowania
</p>

<div class="c">
<pre>#define GG_LOGIN 0x000c</pre>
</div>

<p>
Musimy podaæ kilka informacji:
</p>

<div class="c">
<pre>struct gg_login {
	int uin;		<i>/* numer klienta */</i>
	int hash;		<i>/* hash has³a */</i>
	int status;		<i>/* pocz±tkowy stan */</i>
	int version;		<i>/* wersja klienta */</i>
	int local_ip;		<i>/* mój adres ip */</i>
	short local_port;	<i>/* port, na którym s³ucham */</i>
	char description[];	<i>/* opis, nie musi wyst±piæ */</i>
	int time;		<i>/* czas, nie musi wyst±piæ */</i>
};</pre>
</div>

<p>
Hash has³a w pierwszych wersjach by³ liczony w do¶æ prosty sposób, ale
niestety z któr±¶ zmian± protoko³u wprowadzono nowy algorytm:
</p>

<div class="example">
<pre>int gg_login_hash(char *password, int seed)
{
	unsigned int x, y, z;

	y = seed;

	for (x = 0; *password; password++) {
		x = (x &amp; 0xffffff00) | *password;
		y ^= x;
		y += x;
		x &lt;&lt;= 8;
		y ^= x;
		x &lt;&lt;= 8;
		y -= x;
		x &lt;&lt;= 8;
		y ^= x;

		z = y &amp; 0x1f;
		y = (y &lt;&lt; z) | (y &gt;&gt; (32 - z));
	}

	return y;
}</pre>
</div>

<p>
Liczba oznaczaj±ca wersjê mo¿e byæ jedn± z poni¿szych:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Warto¶æ</b></td><td><b>Wersje klientów</b></td></tr>
<tr class="tabf"><td><tt>0x19</tt></td><td>5.0.3</td></tr>
<tr class="tabf"><td><tt>0x18</tt></td><td>5.0.1, 5.0.0, 4.9.3</td></tr>
<tr class="tabf"><td><tt>0x17</tt></td><td>4.9.2</td></tr>
<tr class="tabf"><td><tt>0x16</tt></td><td>4.9.1</td></tr>
<tr class="tabf"><td><tt>0x15</tt></td><td>4.8.9</td></tr>
<tr class="tabf"><td><tt>0x14</tt></td><td>4.8.3, 4.8.1</td></tr>
<tr class="tabf"><td><tt>0x11</tt></td><td>4.6.10, 4.6.1</td></tr>
<tr class="tabf"><td><tt>0x10</tt></td><td>4.5.22, 4.5.21, 4.5.19, 4.5.17, 4.5.15</td></tr>
<tr class="tabf"><td><tt>0x0f</tt></td><td>4.5.12</td></tr>
<tr class="tabf"><td><tt>0x0b</tt></td><td>4.0.30, 4.0.29, 4.0.28, 4.0.25</td></tr>
</table>

<p>
Oczywi¶cie nie s± to wszystkie mo¿liwe wersje klientów, lecz te, które
uda³o siê z³apaæ na wolno¶ci. Najbezpieczniej bêdzie przedstawiaæ siê jako
ta wersja, której w³asno¶ci u¿ywamy. Wiadomo, ¿e wersje 4.0 nie obs³ugiwa³y
trybu ukrytego, tylko dla znajomych itd.
</p>

<p>
W najnowszej wersji protoko³u jest dodatkowa maska na wersjê:
</p>

<div class="c">
<pre>#define GG_HAS_AUDIO_MASK 0x40000000</pre>
</div>

<p>
która mówi nam, ¿e dany klient mo¿e prowadziæ rozmowy g³osowe.
</p>

<p>
Je¶li wszystko siê powiedzie, dostaniemy w odpowiedzi pakiet typu:
</p>

<div class="c">
<pre>#define GG_LOGIN_OK 0x0003</pre>
</div>

<p>
o zerowej d³ugo¶ci, lub w przypadku b³êdu pakiet:
</p>

<div class="c">
<pre>#define GG_LOGIN_FAILED 0x0009</pre>
</div>

<p>
Od wersji 4.9.3 (protokó³ 0x18), mo¿liwe jest równie¿ wykorzystanie
przekierowania portów. Je¶li chcemy wykorzystaæ, nale¿y zamiast
pakietu GG_LOGIN wys³aæ nastêpuj±cy:
</p>

<div class="c">
<pre>#define GG_LOGIN_EXT 0x0013

struct gg_login_ext {
	int uin;		<i>/* numer klienta */</i>
	int hash;		<i>/* hash has³a */</i>
	int status;		<i>/* pocz±tkowy stan */</i>
	int version;		<i>/* wersja klienta */</i>
	int local_ip;		<i>/* mój adres ip */</i>
	short local_port;	<i>/* port, na którym s³ucham */</i>
	int external_ip;	<i>/* zewnêtrzny adres ip */</i>
	short external_port;	<i>/* zewnêtrzny port */</i>
	char description[];	<i>/* opis, nie musi wyst±piæ */</i>
	int time;		<i>/* czas, nie musi wyst±piæ */</i>
};</pre>
</div>

<hr />

<h3>1.4. Zmiana stanu</h3>

<p>
Gadu-Gadu przewiduje kilka stanów klienta, które zmieniamy pakietem typu:
</p>

<div class="c">
<pre>#define GG_NEW_STATUS 0x0002
	
struct gg_new_status {
	int status;		<i>/* na jaki zmieniæ? */</i>
	char description[];	<i>/* opis, nie musi wyst±piæ */</i>
	int time;		<i>/* czas, nie musi wyst±piæ */</i>
}</pre>
</div>

<p>
Mo¿liwe stany to:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Etykieta</b></td><td><b>Warto¶æ</b></td><td><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><tt>GG_STATUS_NOT_AVAIL</tt></td><td><tt>0x0001</tt></td><td>Niedostêpny</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_NOT_AVAIL_DESCR</tt></td><td><tt>0x0015</tt></td><td>Niedostêpny (z opisem)</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_AVAIL</tt></td><td><tt>0x0002</tt></td><td>Dostêpny</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_AVAIL_DESCR</tt></td><td><tt>0x0004</tt></td><td>Dostêpny (z opisem)</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_BUSY</tt></td><td><tt>0x0003</tt></td><td>Zajêty</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_BUSY_DESCR</tt></td><td><tt>0x0005</tt></td><td>Zajêty (z opisem)</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_INVISIBLE</tt></td><td><tt>0x0014</tt></td><td>Niewidoczny</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_INVISIBLE_DESCR</tt></td><td><tt>0x0016</tt></td><td>Niewidoczny z opisem</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_BLOCKED</tt></td><td><tt>0x0006</tt></td><td>Zablokowany</td></tr>
<tr class="tabf"><td><tt>GG_STATUS_FRIENDS_MASK</tt></td><td><tt>0x8000</tt></td><td>Maska bitowa oznaczaj±ca tryb tylko dla przyjació³</td></tr>
</table>

<p>
Nale¿y pamiêtaæ, ¿eby przed roz³±czeniem siê z serwerem nale¿y zmieniæ
stan na <tt>GG_STATUS_NOT_AVAIL</tt> lub <tt>GG_STATUS_NOT_AVAIL_DESCR</tt>.
Je¶li ma byæ widoczny tylko dla przyjació³, nale¿y dodaæ
<tt>GG_STATUS_FRIENDS_MASK</tt> do normalnej warto¶ci stanu.
</p>

<p>
Je¶li wybieramy stan opisowy, nale¿y do³±czyæ ci±g znaków zakoñczony
zerem oraz ewentualny czas powrotu w postaci ilo¶ci sekund od 1 stycznia
1970r (UTC). Maksymalna d³ugo¶æ opisu wynosi 40 znaków plus zero plus
4 bajty na godzinê powrotu, co razem daje 45 bajtów.
</p>

<hr />

<h3>1.5. Ludzie przychodz±, ludzie odchodz±</h3>

<p>
Zaraz po zalogowaniu mo¿emy wys³aæ serwerowi nasz± listê kontaktów, ¿eby
dowiedzieæ siê, czy s± w danej chwili dostêpni. Pakiet zawiera maksymalnie
409 struktur <tt>gg_notify</tt>:
</p>

<div class="c">
<pre>#define GG_NOTIFY 0x0010
	
struct gg_notify {
	int uin;	<i>/* numerek danej osoby */</i>
	char type;	<i>/* rodzaj u¿ytkownika */</i>
};</pre>	
</div>

<p>
Gdzie pole <tt>type</tt> przyjmuje nastêpuj±ce warto¶ci:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Etykieta</b></td><td><b>Warto¶æ</b></td><td><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><tt>GG_USER_OFFLINE</tt></td><td><tt>0x01</tt></td><td>U¿ytkownik, dla którego bêdziemy niedostêpni</td></tr>
<tr class="tabf"><td><tt>GG_USER_NORMAL</tt></td><td><tt>0x03</tt></td><td>Zwyk³y u¿ytkownik dodany do listy kontkatów</td></tr>
<tr class="tabf"><td><tt>GG_USER_BLOCKED</tt></td><td><tt>0x04</tt></td><td>U¿ytkownik, którego wiadomo¶ci nie chcemy otrzymywaæ</td></tr>
</table>

<!-- Adam pisa³, ¿e jest to bitmapa, w której 0x01 znaczy otwarte okienko
rozmowy z dan± osob±, ale wygl±da³oby to co najmniej dziwnie, wiêc
upro¶ci³em trochê ca³± sprawê. -->

<p>
Je¶li nie mamy nikogo na li¶cie wysy³amy pakiet:
</p>

<div class="c">
<pre>#define GG_LIST_EMPTY 0x0012</pre>
</div>

<p>	
o zerowej d³ugo¶ci.
</p>

<p>
Je¶li kto¶ jest, serwer odpowie pakietem zawieraj±cym jedn± lub wiêcej
struktur <tt>gg_notify_reply</tt>:
</p>

<div class="c">
<pre>#define GG_NOTIFY_REPLY 0x000c	/* tak, to samo co GG_LOGIN */
	
struct gg_notify_reply {
	int uin;		/* numerek */
	int status;		/* status danej osoby */
	int remote_ip;		/* adres ip delikwenta */
	short remote_port;	/* port, na którym s³ucha klient */
	int version;		/* wersja klienta */
	short unknown1;		/* znowu port? */
	char description[];	/* opis, nie musi wyst±piæ */
	int time;		/* czas, nie musi wyst±piæ */
};</pre>
</div>

<p>
Wiêkszo¶æ pól powinna byæ zrozumia³a. <tt>remote_port</tt> poza zwyk³ym
portem mo¿e przyjmowaæ równie¿ poni¿sze warto¶ci:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Warto¶æ</b></td><td><b>Znaczenie</b></td></tr>
<tr class="tabf"><td>0</td><td>Klient nie obs³uguje bezpo¶rednich po³±czeñ</td></tr>
<tr class="tabf"><td>1</td><td>Klient ³±czy siê zza NAT lub innej formy maskarady</td></tr>
<tr class="tabf"><td>2</td><td>Klient nie ma nas w swojej li¶cie kontaktów</td></tr>
</table>

<p>
Zdarzaj± siê te¿ inne ,,nietypowe'' warto¶ci, ale ich znaczenie nie jest
jeszcze do koñca znane.
</p>

<p>
Je¶li dany klient jest w stanie z podanym opisem, najpierw dostaniemy
informacjê osobnym pakietem o nim, pó¼niej paczkê struktur
<tt>gg_notify_reply</tt> z lud¼mi, którzy nie maj± ustawionych opisów.
</p>

<p>
Mo¿liwe jest równie¿ otrzymanie pakietu <tt>gg_notify_reply</tt> ze swoim w³asnym numerem, któr± najlepiej zignorowaæ.
</p>

<p>
¯eby dodaæ kogo¶ do listy w trakcie pracy, trzeba wys³aæ ni¿ej opisany
pakiet. Jego format jest identyczny jak przy <tt>GG_NOTIFY</tt>.
</p>

<div class="c">
<pre>#define GG_ADD_NOTIFY 0x000d
	
struct gg_add {
	int uin;	<i>/* numerek */</i>
	char type;	<i>/* rodzaj u¿ytkownika */</i>
};</pre>
</div>

<p>
By usun±æ z listy kontaktów, wysy³a siê podobny pakiet:
</p>

<div class="c">
<pre>#define GG_REMOVE_NOTIFY 0x000e
	
struct gg_add {
	int uin;	<i>/* numerek */</i>
	char type;	<i>/* rodzaj u¿ytkownika */</i>
};</pre>
</div>

<p>
Je¶li kto¶ opu¶ci Gadu-Gadu lub zmieni stan na niedostêpny lub niewidoczny, otrzymamy pakiet:
</p>

<div class="c">
<pre>#define GG_STATUS 0x0002
	
struct gg_status {
	int uin;	        <i>/* numerek */</i>
	int status;	        <i>/* nowy stan */</i>
	char description[];	<i>/* opis, nie musi wyst±piæ */</i>
	int time;		<i>/* czas, nie musi wyst±piæ */</i>
};</pre>
</div>

<p>
Natomiast je¶li kto¶ zmieni status na inny ni¿ niedostêpny lub niewidoczny, otrzymamy pakiet <tt>gg_notify_reply</tt>.
</p>

<hr />

<h3>1.6. Wysy³anie wiadomo¶ci</h3>

<p>
Wiadomo¶ci wysy³a siê nastêpuj±cym typem pakietu:
</p>

<div class="c">
<pre>#define GG_SEND_MSG 0x000b

struct gg_send_msg {
	int recipient;		<i>/* numer odbiorcy */</i>
	int seq;		<i>/* numer sekwencyjny */</i>
	int class;		<i>/* klasa wiadomo¶ci */</i>
	char message[];		<i>/* tre¶æ */</i>
};</pre>
</div>

<p>
Numer sekwencyjny jest wykorzystywany przy potwierdzeniu dostarczenia
lub zakolejkowania pakietu. Nie jest wykluczone, ¿e w jakis sposób odró¿nia
siê ró¿ne rozmowy za pomoc± czê¶ci bajtów, ale raczej nie powinno mieæ to
ma znaczenia. Klasa wiadomo¶ci pozwala odró¿niæ, czy wiadomo¶æ ma siê
pojawiæ w osobnym okienku czy jako kolejna linijka w okienku rozmowy. Jest
to mapa bitowa, wiêc najlepiej ignorowaæ te bity, których znaczenia nie
znamy:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Etykieta</b></td><td><b>Warto¶æ</b></td><td><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><tt>GG_CLASS_QUEUED</tt></td><td><tt>0x0001</tt></td><td>Bit ustawiany wy³±cznie przy odbiorze wiadomo¶ci, gdy wiadomo¶æ zosta³a wcze¶niej zakolejkowania z powodu nieobecno¶ci</td></tr>
<tr class="tabf"><td><tt>GG_CLASS_MSG</tt></td><td><tt>0x0004</tt></td><td>Wiadomo¶æ ma siê pojawiæ w osobnym okienku</td></tr>
<tr class="tabf"><td><tt>GG_CLASS_CHAT</tt></td><td><tt>0x0008</tt></td><td>Wiadomo¶æ jest czê¶ci± tocz±cej siê rozmowy i zostanie wy¶wietlona w istniej±cym okienku</td></tr>
<tr class="tabf"><td><tt>GG_CLASS_CTCP</tt></td><td><tt>0x0010</tt></td><td>Wiadomo¶æ jest przeznaczona dla klienta Gadu-Gadu i nie powinna byæ wy¶wietlona u¿ytkownikowi.</td></tr>
<tr class="tabf"><td><tt>GG_CLASS_ACK</tt></td><td><tt>0x0020</tt></td><td>Klient nie ¿yczy sobie potwierdzenia wiadomo¶ci.</td></tr>
</table>

<p>
D³ugo¶æ tre¶ci wiadomo¶ci nie powinna przekraczaæ 2000 znaków. Oryginalny
klient zezwala na wys³anie do 1989 znaków.
</p>

<p>
Oryginalny klient wysy³aj±c wiadomo¶æ do kilku u¿ytkowników, wysy³a po
kilka takich samych pakietów z ró¿nymi numerkami odbiorców. Nie ma osobnego
pakietu do tego. Natomiast je¶li chodzi o <i>po³±czenia konferencyjne</i>
do pakietu doklejana jest nastêpuj±ca struktura:
</p>

<div class="c">
<pre>struct gg_msg_recipients {
	char flag;		<i>/* == 1 */</i>
	int count;		<i>/* ilo¶æ odbiorców */</i>
	int recipients[];	<i>/* tablica odbiorców */</i>
};</pre>
</div>

<p>
Na przyk³ad, by wys³aæ do dwóch osób, nale¿y wys³aæ pakiet:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Offset</b></td><td><b>Warto¶æ</b></td></tr>
<tr class="tabf"><td><i>n</i></td><td>Tre¶æ wiadomo¶ci</td></tr>
<tr class="tabf"><td><i>m</i></td><td><tt>0x01</tt> (wiadomo¶æ konferencyjna)</td></tr>
<tr class="tabf"><td><i>m</i>&nbsp;+&nbsp;1</td><td rowspan="4"><tt>0x02</tt> (ilo¶æ adresatów)</td></tr>
<tr class="tabf"><td><i>m</i>&nbsp;+&nbsp;2</td></tr>
<tr class="tabf"><td><i>m</i>&nbsp;+&nbsp;3</td></tr>
<tr class="tabf"><td><i>m</i>&nbsp;+&nbsp;4</td></tr>
<tr class="tabf"><td><i>m</i>&nbsp;+&nbsp;5</td><td rowspan="4">Numer pierwszego adresata</td></tr>
<tr class="tabf"><td><i>m</i>&nbsp;+&nbsp;6</td></tr>
<tr class="tabf"><td><i>m</i>&nbsp;+&nbsp;7</td></tr>
<tr class="tabf"><td><i>m</i>&nbsp;+&nbsp;8</td></tr>
<tr class="tabf"><td><i>m</i>&nbsp;+&nbsp;9</td><td rowspan="4">Numer drugiego adresata</td></tr>
<tr class="tabf"><td><i>m</i>&nbsp;+&nbsp;10</td></tr>
<tr class="tabf"><td><i>m</i>&nbsp;+&nbsp;11</td></tr>
<tr class="tabf"><td><i>m</i>&nbsp;+&nbsp;12</td></tr>
</table>

<p>
Od wersji 4.8.1 mo¿liwe jest równie¿ dodawanie do wiadomo¶ci ró¿nych
atrybutów tekstu jak pogrubienie czy kolory. Niezbêdne jest do³±czenie
nastêpnuj±cej struktury:
</p>

<div class="c">
<pre>struct gg_msg_richtext {
	char flag;	<i>/* == 2 */</i>
	short length;	<i>/* d³ugo¶æ dalszej czê¶ci */</i>
};</pre>
</div>

<p>
Dalsza czê¶æ pakietu zawiera odpowiedni± ilo¶æ struktur o ³±czej d³ugo¶ci
okre¶lonej polem <tt>length</tt>:
</p>

<div class="c">
<pre>struct gg_msg_richtext_format {
	short position;	<i>/* pozycja atrybutu w tek¶cie */</i>
	char font;	<i>/* atrybuty czcionki */</i>
	char rgb[3];	<i>/* kolor czcionki, nie musi wyst±piæ */</i>
};</pre>
</div>

<p>
Ka¿da z tych struktur okre¶la kawa³ek tekstu pocz±wszy od znaku okre¶lonego
przez pole <tt>position</tt> (liczone od zera) a¿ do nastêpnego wpisu lub
koñca tekstu. Pole <tt>font</tt> jest map± bitow± i kolejne bity maj±
nastêpuj±ce znaczenie:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Etykieta</b></td><td><b>Warto¶æ</b></td><td><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><tt>GG_FONT_BOLD</tt></td><td><tt>0x01</tt></td><td>Pogrubiony tekst</td></tr>
<tr class="tabf"><td><tt>GG_FONT_ITALIC</tt></td><td><tt>0x02</tt></td><td>Kursywa</td></tr>
<tr class="tabf"><td><tt>GG_FONT_UNDERLINE</tt></td><td><tt>0x04</tt></td><td>Podkre¶lenie</td></tr>
<tr class="tabf"><td><tt>GG_FONT_COLOR</tt></td><td><tt>0x08</tt></td><td>Kolorowy tekst. Tylko w tym wypadku struktura <tt>gg_msg_richtext_format</tt> zawiera pole <tt>rgb[]</tt> bêd±ce opisem trzech sk³adowych koloru, kolejno czerwonej, zielonej i niebieskiej.</td></tr>
</table>

<p>
Dla przyk³adu, by przes³aæ tekst ,,ala <b>ma</b> kota'', nale¿y do³±czyæ do
wiadomo¶ci nastêpuj±c± sekwencjê bajtów:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Offset</b></td><td><b>Warto¶æ</b></td><td><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><i>n</i></td><td><tt>0x02</tt></td><td>Opis atrybutów tekstu...</td></tr>
<tr class="tabf"><td><i>n</i> + 1</td><td rowspan="2"><tt>0x0006</tt></td><td rowspan="2">...maj±cy 6 bajtów d³ugo¶ci</td></tr>
<tr class="tabf"><td><i>n</i> + 2</td></tr>
<tr class="tabf"><td><i>n</i> + 3</td><td rowspan="2"><tt>0x0004</tt></td><td rowspan="2">Atrybut zaczyna siê od pozycji 4...</td></tr>
<tr class="tabf"><td><i>n</i> + 4</td></tr>
<tr class="tabf"><td><i>n</i> + 5</td><td><tt>0x01</tt></td><td>...i jest to pogrubiony tekst</td></tr>
<tr class="tabf"><td><i>n</i> + 6</td><td rowspan="2"><tt>0x0006</tt></td><td rowspan="2">Atrybut zaczyna siê od pozycji 6...</td></tr>
<tr class="tabf"><td><i>n</i> + 7</td></tr>
<tr class="tabf"><td><i>n</i> + 8</td><td><tt>0x00</tt></td><td>...i jest to zwyk³y tekst</td></tr>
</table>

<p>
Serwer po otrzymaniu wiadomo¶ci odsy³a potwierdzenie, które przy okazji
mówi nam, czy wiadomo¶æ dotar³a do odbiorcy czy zosta³a zakolejkowana
z powodu nieobecno¶ci. Otrzymujemy je w postaci pakietu:
</p>

<div class="c">
<pre>#define GG_SEND_MSG_ACK 0x0005
	
struct gg_send_msg_ack {
	int status;	<i>/* stan wiadomo¶ci */</i>
	int recipient;	<i>/* numer odbiorcy */</i>
	int seq;	<i>/* numer sekwencyjny */</i>
};</pre>
</div>

<p>
Numer sekwencyjny i numer adresata s± takie same jak podczas wysy³ania,
a stan wiadomo¶ci mo¿e byæ jednym z nastêpuj±cych:
</p>

<table class="tab" border="0" cellspacing="1" cellpadding="2" width="100%">
<tr class="tabh"><td><b>Etykieta</b></td><td><b>Warto¶æ</b></td><td><b>Znaczenie</b></td></tr>
<tr class="tabf"><td><tt>GG_ACK_DELIVERED</tt></td><td><tt>0x0002</tt></td><td>Wiadomo¶æ dostarczono</td></tr>
<tr class="tabf"><td><tt>GG_ACK_QUEUED</tt></td><td><tt>0x0003</tt></td><td>Wiadomo¶æ zakolejkowano</td></tr>
<tr class="tabf"><td><tt>GG_ACK_MBOXFULL</tt></td><td><tt>0x0004</tt></td><td>Wiadomo¶ci nie dostarczono. Skrzynka odbiorcza na serwerze jest pe³na (20 wiadomo¶ci maks). Wystêpuje tylko w trybie offline</td></tr>
<tr class="tabf"><td><tt>GG_ACK_NOT_DELIVERED</tt></td><td><tt>0x0006</tt></td><td>Wiadomo¶ci nie dostarczono. Odpowied¼ ta wystêpuje tylko w przypadku wiadomo¶ci klasy <tt>GG_CLASS_CTCP</tt></td></tr>
</table>

<hr />

<h3>1.7. Otrzymywanie wiadomo¶ci</h3>

<p>
Wiadomo¶ci serwer przysy³a za pomoc± pakietu:
</p>

<div class="c">
<pre>#define GG_RECV_MSG 0x000a
	
struct gg_recv_msg {
	int sender;		<i>/* numer nadawcy */</i>
	int seq;		<i>/* numer sekwencyjny */</i>
	int time;		<i>/* czas nadania */</i>
	int class;		<i>/* klasa wiadomo¶ci */</i>
	char message[];		<i>/* tre¶æ wiadomo¶ci */</i>
};</pre>
</div>

<p>
Czas nadania jest zapisany w postaci UTC, jako ilo¶ci sekund od 1 stycznie
1970r.
</p>

<p>
W przypadku pakietów ,,konferencyjnych'' na koñcu pakietu doklejona jest
struktura identyczna z <tt>gg_msg_recipients</tt> zawieraj±ca pozosta³ych
rozmówców.
</p>

<hr />

<h3>1.8. Ping, pong</h3>

<p>
Od czasu do czasu klient wysy³a pakiet do serwera, by oznajmiæ, ¿e po³±czenie
jeszcze jest utrzymywane. Je¶li serwer nie dostanie takiego pakietu w
przeci±gu 5 minut, zrywa po³±czenie. To, czy klient dostaje odpowied¼
zmienia siê z wersji na wersjê, wiêc najlepiej nie polegaæ na tym.
</p>

<div class="c">
<pre>#define GG_PING 0x0008

#define GG_PONG 0x0007</pre>
</div>

<hr />

<h3>1.9. Roz³±czenie</h3>

<p>
Je¶li serwer zechce nas roz³±czyæ, wy¶le wcze¶niej pusty pakiet:
</p>

<div class="c">
<pre>#define GG_DISCONNECTING 0x000b</pre>
</div>

<p>
Ma to miejsce, gdy próbowano zbyt wiele razy po³±czyæ siê z nieprawid³owym
has³em, lub gdy równocze¶nie po³±czy siê drugi klient z tym samym numerem
(nowe po³±czenie ma wy¿szy priorytet).
</p>

<hr />

<h2>2. Us³ugi HTTP</h2>

<p>
Opis znajduje siê w pliku <a href="http.txt">http.txt</a>.
</p>

<hr />

<h2>3. Bezpo¶rednie po³±czenie</h2>

<p>
Opis znajduje siê w pliku <a href="dcc-protocol.txt">dcc-protocol.txt</a>.
</p>

<a name="ch4"></a>
	
<hr />

<h2>4. Autorzy</h2>

<p>
Autorami powy¿szego opisu s±:
</p>

<ul>
	<li><b>Wojtek Kaniewski</b> (wojtekka%irc.pl): pierwsza wersja opisu, poprawki, utrzymanie wszystkiego w porz±dku.</li>
	<li><b>Robert J. Wo¼ny</b> (speedy%atman.pl): opis nowo¶ci w protokole GG 4.6, poprawki.</li>
	<li><b>Tomasz Jarzynka</b> (tomee%cpi.pl): badanie timeoutów.</li>
	<li><b>Adam Ludwikowski</b> (adam.ludwikowski%wp.pl): wiele poprawek, wersje klientów, rozszerzone wiadomo¶ci, powody nieobecno¶ci.</li>
	<li><b>Marek Kozina</b> (klith%hybrid.art.pl): czas otrzymania wiadomo¶ci.</li>
	<li><b>Rafa³ Florek</b> (raf%regionet.regionet.pl): opis po³±czeñ konferencyjnych.</li>
	<li><b>Igor Popik</b> (igipop%wsfiz.edu.pl): klasy wiadomo¶ci przy odbieraniu zakolejkowanej.</li>
	<li><b>Rafa³ Cyran</b> (ajron%wp.pl): informacje o remote_port, rodzaje potwierdzeñ przy ctcp, GG_LOGIN_EXT.</li>
	<li><b>Piotr Mach</b> (pm%gadu-gadu.com): ilo¶æ kontaktow, pe³na skrzynka, pusta lista, maska audio, us³ugi HTTP, GG_LOGIN_EXT.</li>
	<li><b>Adam Czy¶ciak</b> (acc%interia.pl): potwierdzenie wiadomo¶ci GG_CLASS_ACK.</li>
	<li><b>Kamil Dêbski</b> (kdebski%kki.net.pl): czas w stanach opisowych.</li>
	<li><b>Pawe³ Piwowar</b> (alfapawel%go2.pl): format czasu.</li>
	<li><b>Tomasz Chiliñski</b> (chilek%chilan.com): nowo¶ci w 5.0.2.</li>
	<li><b>Rados³aw Nowak</b> (rano%ranosoft.com): uzupe³nienie statusu opisowego, wersja 5.0.3.</li>
</ul>

<hr />

<font color="silver">
$Id$
</font>

</td></tr></table>
</center>

</body>
</html>
