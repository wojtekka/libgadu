<!-- (C) Copyright 2001-2002 by ekg team -->
<html>
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-2">
</head>
<body bgcolor=white text=black>
<center>
<h1>Protokó³ Gadu-Gadu</h1>
<h3>&copy; Copyright 2001-2002 by <a href="#ch4">Autorzy</a></h3>
</center>

<hr>
<h2>0. Informacje wstêpne</h2>
<p>
Opis protoko³u u¿ywanego przez Gadu-gadu bazuje na do¶wiadczeniach
przeprowadzonych przez autorów oraz informacjach nadsy³anych przez 
u¿ytkowników. ¯aden klient Gadu-gadu nie zosta³ skrzywdzony podczas
badañ. Reverse-engineering opiera³ siê g³ównie na analizie pakietów
wysy³anych miêdzy klientem a serwerem.
</p>

<hr>
<h2>1. Protokó³ Gadu-gadu</h2>

<h3>1.1. Format pakietów</h3>
<p>
Podobnie jak coraz wiêksza ilo¶æ komunikatorów, Gadu-gadu korzysta z
protoko³u TCP/IP. Ka¿dy pakiet zawiera na pocz±tku dwa sta³e pola:
</p>
<p><pre>
        struct gg_header {
		int type;		/* typ pakietu */
		int length;		/* d³ugo¶æ reszty pakietu */
	};
</pre></p>
<p>
Wszystkie zmienne liczbowe s± zgodne z kolejno¶ci± bajtów maszyn Intela,
czyli Little-Endian.
</p>
<p>
Przy opisie struktur, za³o¿ono, ¿e <tt>char</tt> ma rozmiar 1 bajtu,
<tt>short</tt> 2 bajtów, <tt>int</tt> 4 bajtów. U¿ywaj±c innych
architektur ni¿ i386 nale¿y zwróciæ szczególn± uwagê na rozmiar typów
zmiennych i kolejno¶æ znaków.
</p>
<p>
Pola, który znaczenie jest nieznane, lub nie do koñca jasne, oznaczono
przedrostkiem <tt>unknown</tt>.
</p>

<hr>
<h3>1.2. Zanim siê po³±czymy</h3>
<p>
¯eby wiedzieæ, z jakim serwerem mamy siê po³±czyæ, nale¿y poudawaæ przez
chwilê przegl±darkê WWW i po³±czyæ siê z hostem <tt>appmsg.gadu-gadu.pl</tt>.
<p><p><pre>
	GET /appsvc/appmsg.asp?fmnumber=<b>NumerGG</b> HTTP/1.0
	Host: appmsg.gadu-gadu.pl
	User-Agent: Mozilla/4.7 [en] (Win98; I)
	Pragma: no-cache
</pre></p>
Oryginalny klient mo¿e wys³aæ jeden z podanych identyfikatorów przegl±darki:
<p><p><pre>
	Mozilla/4.04 [en] (Win95; I ;Nav)
	Mozilla/4.7 [en] (Win98; I)
	Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)
	Mozilla/4.0 (compatible; MSIE 5.0; Windows NT)
	Mozilla/4.0 (compatible; MSIE 5.0; Windows 98; DigExt)
	Mozilla/4.0 (compatible; MSIE 5.0; Windows 98)
</pre></p>
Nowsze wersje klienta do zapytania dodaj± równie¿ pole
<tt>version=<b>x.y</b></tt> opisuj±ce, z jakim klientem
serwer ma do czynienia. Jednak ze wzglêdu na mo¿liwe ró¿nice w protokole i
inne traktowanie ró¿nych wersji klienta, lepiej pomijaæ ten parametr. Na
postawione wcze¶niej zapytanie, serwer powinien odpowiedzieæ:
<p><p><pre>
	HTTP/1.0 200 OK
	
	124 1 0 217.17.33.21:8074 0.0.0.0
</pre></p>
nie mam pojêcia ;) wygl±da na to, ¿e ca³y g*du-g*du jest
przemy¶lany i w przysz³o¶ci bêdzie mo¿na u¿ywaæ ró¿nych serwerów do ró¿nych
rzeczy, typu szukanie, obs³uga klientów itd. póki co, ³±czyæ siê trzeba na
pierwszy adres (tak, ten z portem).
Je¿eli po³±czenie z portem 8074 nie wyjdzie z jaki¶ specyficznych powodów -
mo¿na siê ³±czyæ na port 443. 

<hr>
<h3>1.3. Logowanie siê</h3>
<p>
po po³±czeniu siê portem serwera g*du-g*du, dostajemy pakiet typu 0x0001,
który na potrzeby tego dokumentu nazwiemy:
<p><p><pre>
	#define GG_WELCOME 0x0001
</pre></p>
reszta pakietu zawiera liczbê, na podstawie której liczony jest hash z has³a
klienta:
<p><p><pre>
	struct gg_welcome {
		int key;		/* klucz szyfrowania has³a */
	};
</pre></p>	
kiedy mamy ju¿ t± warto¶æ mo¿emy odes³aæ pakiet logowania
<p><p><pre>
	#define GG_LOGIN 0x000c
</pre></p>
musimy podaæ kilka informacji:
<p><p><pre>
	struct gg_login {
		int uin;		/* twój numerek */
		int hash;		/* hash has³a */
		int status;		/* status na dzieñ dobry */
		int version;		/* wersja klienta */
		int local_ip;		/* mój adres ip */
		short local_port;	/* port, na którym s³ucham */
	};
</pre></p>
jak obliczyæ hash has³a? hmm... nic prostszego. do ka¿dej literki has³a
dodaje siê jedynkê, mno¿y wszystko razem, a potem przez liczbê podan± przez
serwer. 
<p><p><pre>
	for (hash = 1; *passwd; passwd++)
		hash *= (*passwd) + 1;
</pre></p>
zrozumia³e, racja? liczba oznaczaj±ca wersjê mo¿e byæ jedn± z poni¿szych:
<p><p><pre>
	0x11 - 4.6.1
	0x10 - 4.5.22, 4.5.21, 4.5.19, 4.5.17, 4.5.15
	0x0f - 4.5.12
	0x0b - 4.0.30, 4.0.29, 4.0.28, 4.0.25
</pre></p>
oczywi¶cie nie s± to wszystkie mo¿liwe wersje klientów, lecz te, które
uda³o siê sprawdziæ. najbezpieczniej bêdzie przedstawiaæ siê jako ta
wersja, której ficzerów u¿ywamy. wiadomo, ¿e 4.0.x nie obs³ugiwa³y trybu
ukrytego, ani tylko dla znajomych itd.
<p>
je¶li wszystko siê powiedzie, dostaniemy w odpowiedzi pakiet typu
<p><p><pre>
	#define GG_LOGIN_OK 0x0003
</pre></p>
z polem header->length = 0, lub pakiet
<p><p><pre>
	#define GG_LOGIN_FAILED 0x0009
</pre></p>

<hr>
<h3>1.4. Zmiana stanu</h3>
<p>
g*du-g*du przewiduje trzy stany klienta, które zmieniamy pakietem
<p><p><pre>
	#define GG_NEW_STATUS 0x0002

	#define GG_STATUS_NOT_AVAIL 0x0001	/* roz³±czony */
	#define GG_STATUS_AVAIL 0x0002		/* dostêpny */
	#define GG_STATUS_BUSY 0x0003		/* zajêty */
	#define GG_STATUS_INVISIBLE 0x0014	/* niewidoczny */

	#define GG_STATUS_FRIENDS_MASK 0x8000	/* tylko dla przyjació³ */
	
	struct gg_new_status {
		int status;			/* na jaki zmieniæ? */
	}
</pre></p>
nale¿y pamiêtaæ, ¿eby przed roz³±czeniem siê z serwerem nale¿y zmieniæ
stan na GG_STATUS_NOT_AVAIL. je¶li ma byæ widoczny tylko dla przyjació³,
nale¿y dodaæ GG_STATUS_FRIENDS do normalnej warto¶ci stanu.

<hr>
<h3>1.5. Ludzie przychodz±, ludzie odchodz±</h3>
<p>
zaraz po zalogowaniu mo¿emy wys³aæ serwerowi listê ludzików w naszej li¶cie
kontaktów, ¿eby dowiedzieæ siê, czy s± w tej chwili dostêpni. pakiet zawiera
dowoln± ilo¶æ struktur gg_notify:
<p><p><pre>
	#define GG_NOTIFY 0x0010
	
	struct gg_notify {
		int uin;		/* numerek danej osoby */
		char dunno1;		/* == 3 */
	};
</pre></p>	
je¶li kto¶ jest, serwer odpowie pakietem zawieraj±cym jedn± lub wiêcej
struktur gg_notify_reply:
<p><p><pre>
	#define GG_NOTIFY_REPLY 0x000c	/* tak, to samo co GG_LOGIN */
	
	struct gg_notify_reply {
		int uin;		/* numerek */
		int status;		/* status danej osoby */
		int remote_ip;		/* adres ip delikwenta */
		short remote_port;	/* port, na którym s³ucha klient */
		int version;		/* wersja klienta */
		short dunno1;		/* znowu port? */
	};
</pre></p>
wiêkszo¶æ pól powinna byæ zrozumia³a. remote_port poza zwyk³ym portem
mo¿e przyjmowaæ równie¿ poni¿sze warto¶ci:
<p><p><pre>
        0 - klient nie obs³uguje bezpo¶rednich po³±czeñ,
	1 - klient jest za NAT,
	2 - klient nie ma nas w swojej li¶cie kontaktów.
</pre></p>
zdarzaj± siê te¿ inne ,,nietypowe'' warto¶ci, ale ich znaczenie nie jest
jeszcze do koñca znane.
<p>
¿eby dodaæ kogo¶ do listy w trakcie pracy, trzeba wys³aæ ni¿ej opisany
pakiet. jego format jest identyczny jak przy GG_NOTIFY.
<p><p><pre>
	#define GG_ADD 0x000d
	
	struct gg_add {
		int uin;		/* numerek */
		char dunno1;		/* == 3 */
	};
</pre></p>
je¶li kto¶ opu¶ci g*du-g*du lub zmieni stan, otrzymamy pakiet
<p><p><pre>
	#define GG_STATUS 0x0002
	
	struct gg_status {
		int uin;		/* numerek */
		int status;		/* nowy stan */
	};
</pre></p>

<hr>
<h3>1.6. Wysy³anie wiadomo¶ci</h3>
<p>
przejd¼my do sedna sprawy ;)
<p><p><pre>
	#define GG_SEND_MSG 0x000b

	#define GG_CLASS_QUEUED 0x0001	/* tylko przy odbieraniu */
	#define GG_CLASS_MSG 0x0004
	#define GG_CLASS_CHAT 0x0008
	#define GG_CLASS_CTCP 0x0010	/* dla klienta GG */
	#define GG_CLASS_UNKNOWN_1 0x0020

	struct gg_send_msg {
		int recipient;
		int seq;
		int class;
		char message[];
	};
</pre></p>
wiadomo, odbiorca. numer sekwencyjny, który wykorzystujemy potem do
potwierdzenia. nie wykluczone, ¿e w jakis sposób odró¿nia siê ró¿ne
rozmowy za pomoc± czê¶ci bajtów, ale raczej nie ma znaczenia. klasa
wiadomo¶ci pozwala odró¿niæ, czy wiadomo¶æ ma siê pokazaæ w osobym
okienku czy jako kolejna linijka w okienku rozmowy. wygl±da na to,
¿e to jaka¶ bitmapa, wiêc najlepiej olaæ inne bity ni¿ 0x0e. (czasem
klienty wysy³aj± 0x04, czasem 0x24 -- widocznie 0x20 to te¿ jaka¶
flaga). je¶li odbiorca bêdzie niedostêpny podczas wysy³ania wiadomo¶ci,
odbierze j± z zaznaczonym bitem GG_CLASS_QUEUED. wiadomo¶æ nie powinna
przekraczaæ 2000 znaków.
<p>
oryginalny klient wysy³aj±c wiadomo¶æ do kilku u¿ytkowników, wysy³a po
prostu kilka takich samych pakietów z ró¿nymi numerkami odbiorców. nie
ma osobnego pakietu do tego. natomiast je¶li chodzi o ,,konferencyjnê''
do pakietu doklejana jest za ,,char message[];'' nastêpuj±ca struktura:
<p><p><pre>
	struct gg_send_recipients {
		char flag;		/* == 1 */
		int count;		/* ilo¶æ odbiorców */
		int recipients[];	/* tablica odbiorców */
	};
</pre></p>
na przyk³ad, by wys³aæ do trzech ludzi, nale¿y wys³aæ pakiet:
<p><p><pre>
	- -- --- --+--+--+--+--+--+--+-----------+-----------+
          tre¶æ    |\0|\1|    0x02   |    uin1   |   uin2    |
	- -- -- ---+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</pre></p>
serwer po otrzymaniu wiadomo¶ci odsy³a informacjê o tym. przy okazji
mówi, czy wiadomo¶æ dotar³a do odbiorcy (status == GG_ACK_DELIVERED),
czy mo¿e jest offline i zosta³a zakolejkowana (GG_ACK_QUEUED). je¶li
by³a wysy³ana wiadomo¶æ do wiadomo¶ci klienta (GG_MSG_CLASS_CTCP),
przy nieobecno¶ci odbiorcy, zostanie zwrócone GG_ACK_NOT_DELIVERED.
<p><p><pre>
	#define GG_SEND_MSG_ACK 0x0005
	
	#define GG_ACK_DELIVERED 0x0002
	#define GG_ACK_QUEUED 0x0003
	#define GG_ACK_NOT_DELIVERED 0x0006

	struct gg_send_msg_ack {
		int status;
		int recipient;
		int seq;
	};
</pre></p>
numer sekwencyjny i adresat ten sam, co przy wysy³aniu.

<hr>
<h3>1.7. Otrzymywanie wiadomo¶ci</h3>
<p>
zbyt wiele wyja¶nieñ chyba nie trzeba. wiadomo od kogo. drugie pole to
najprawdopodobniej jaki¶ numerek sekwencyjny. trzecie oznacza czas nadania
wiadomo¶ci. klasa wiadomo¶ci taka sama jak przy wysy³aniu:
<p><p><pre>
	#define GG_RECV_MSG 0x000a
	
	struct gg_recv_msg {
		int sender;
		int seq;
		int time;
		int class;
		char message[];
	};
</pre></p>
w przypadku pakietów ,,konferencyjnych'' na koncu pakietu doklejona jest
struktura identyczna ze struct gg_send_recipients zawieraj±ca pozosta³ych
rozmówców.

<hr>
<h3>1.8. Ping/pong</h3>
<p>
od czasu do czasu klient wysy³a pakiet a'la ping do serwera i dostaje pust±
odpowied¼. o ile dobrze pamiêtam, serwer roz³±cza siê po up³ywie 5 minut od
otrzymania ostatniej informacji.
<p><p><pre>
	#define GG_PING 0x0008
	
	/* nie ma niczego */
	
	#define GG_PONG 0x0007
	
	/* nie ma niczego */
</pre></p>

<hr>
<h3>1.9. Roz³±czenie</h3>
<p>
je¶li serwer zechce nas roz³±czyæ, wy¶le wcze¶niej pusty pakiet:
<p><p><pre>
	#define GG_DISCONNECTING 0x000b
	
	/* nie ma niczego */
</pre></p>

<hr>
<h2>2. Us³ugi HTTP</h2>
<p>
Do zrobienia.

<hr>
<h2>3. Bezpo¶renie po³±czenie</h2>
<p>
Do zrobienia.

<a name="ch4">
<hr>
<h2>4. Autorzy</h2>
<p>
Autorami powy¿szego opisu s±:
<ul>
<li>Wojtek Kaniewski (wojtekka/irc.pl): pierwsza wersja opisu, poprawki.
<li>Robert J. Wo¼ny (speedy/atman.pl): opis nowo¶ci w protokole GG 4.6, poprawki.
<li>Tomasz Jarzynka (tomee/cpi.pl): badanie timeoutów.
<li>Adam Ludwikowski (adam.ludwikowski/wp.pl): wiele poprawek, wersje klientów.
<li>Marek Kozina (klith/hybrid.art.pl): czas otrzymania wiadomo¶ci.
<li>Rafa³ Florek (raf/regionet.regionet.pl): opis po³±czeñ konferencyjnych.
<li>Igor Popik (igipop/wsfiz.edu.pl): klasy wiadomo¶ci przy odbieraniu zakolejkowanej.
<li>Rafa³ Cyran (ajron/wp.pl): informacje o remote_port, rodzaje potwierdzeñ przy ctcp.
</ul>

<hr>
<font color=silver>
$Id$
</font>

</body>
</html>
